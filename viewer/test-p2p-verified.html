<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>P2P HLS v2.2.1 - Triple-Verified Stats</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #0b0f14;
      color: #e6eef7;
      padding: 20px;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    h1 {
      text-align: center;
      margin-bottom: 10px;
      font-size: 2rem;
      background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .subtitle {
      text-align: center;
      color: #888;
      margin-bottom: 20px;
    }

    .warning {
      background: rgba(255, 107, 107, 0.2);
      border: 2px solid #ff6b6b;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 20px;
    }

    .test-section {
      background: #101826;
      border: 1px solid #223040;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
    }

    h2 {
      color: #4ecdc4;
      margin-bottom: 15px;
    }

    h3 {
      color: #ffa600;
      margin: 15px 0 10px 0;
      font-size: 1.1rem;
    }

    button {
      background: #4ecdc4;
      color: #000;
      border: none;
      padding: 12px 24px;
      font-size: 1.1rem;
      font-weight: 600;
      border-radius: 8px;
      cursor: pointer;
      margin: 10px 10px 10px 0;
      transition: transform 0.1s;
    }

    button:hover {
      transform: scale(1.05);
    }

    button:active {
      transform: scale(0.95);
    }

    .video-container {
      position: relative;
      background: #000;
      border-radius: 8px;
      overflow: hidden;
      margin: 15px 0;
      aspect-ratio: 16/9;
    }

    video {
      width: 100%;
      height: 100%;
      display: block;
      object-fit: contain;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 10px;
      margin: 15px 0;
    }

    .stat-box {
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid #223040;
      border-radius: 6px;
      padding: 10px;
    }

    .stat-box.mismatch {
      border: 2px solid #ff6b6b;
      background: rgba(255, 107, 107, 0.1);
    }

    .stat-label {
      color: #888;
      font-size: 0.8rem;
      margin-bottom: 5px;
    }

    .stat-value {
      color: #4ecdc4;
      font-size: 1.4rem;
      font-weight: 600;
    }

    .stat-verify {
      color: #666;
      font-size: 0.7rem;
      margin-top: 5px;
      font-family: monospace;
    }

    .verification {
      background: rgba(78, 220, 196, 0.1);
      border: 1px solid #4ecdc4;
      border-radius: 6px;
      padding: 15px;
      margin: 15px 0;
    }

    .verification.error {
      background: rgba(255, 107, 107, 0.1);
      border-color: #ff6b6b;
    }

    .log {
      background: #000;
      border: 1px solid #223040;
      border-radius: 6px;
      padding: 15px;
      max-height: 400px;
      overflow-y: auto;
      font-family: 'Courier New', monospace;
      font-size: 0.8rem;
      margin-top: 15px;
    }

    .log-entry {
      padding: 2px 0;
      border-bottom: 1px solid #111;
    }

    .log-time { color: #666; margin-right: 10px; }
    .log-info { color: #4ecdc4; }
    .log-warn { color: #ffa600; }
    .log-error { color: #ff6b6b; }
    .log-verify { color: #9b59b6; }
  </style>
</head>
<body>
  <div class="container">
    <h1>üî¨ P2P HLS v2.2.1 - Triple-Verified Stats</h1>
    <p class="subtitle">Multiple verification methods to prove P2P accuracy</p>

    <div class="warning">
      <strong>‚ö†Ô∏è Verification Mode:</strong> This page tracks downloads using 3 different methods and cross-verifies them.
      Any mismatches will be flagged immediately. Trust no stat until verified! üïµÔ∏è
    </div>

    <div class="test-section">
      <h2>üì∫ Test Stream</h2>
      
      <button onclick="playStream()">‚ñ∂Ô∏è Start Test</button>
      <button onclick="stopStream()">‚èπÔ∏è Stop</button>

      <div class="video-container">
        <video id="video" controls playsinline></video>
      </div>

      <h3>üìä Triple-Verified Stats</h3>
      <div class="stats-grid">
        <div class="stat-box" id="p2p-box">
          <div class="stat-label">P2P Downloaded</div>
          <div class="stat-value" id="p2p-mb">0 MB</div>
          <div class="stat-verify" id="p2p-verify">Waiting...</div>
        </div>
        <div class="stat-box" id="http-box">
          <div class="stat-label">HTTP Downloaded</div>
          <div class="stat-value" id="http-mb">0 MB</div>
          <div class="stat-verify" id="http-verify">Waiting...</div>
        </div>
        <div class="stat-box">
          <div class="stat-label">P2P Ratio</div>
          <div class="stat-value" id="p2p-ratio">0%</div>
          <div class="stat-verify" id="ratio-verify">Waiting...</div>
        </div>
        <div class="stat-box">
          <div class="stat-label">Active Peers</div>
          <div class="stat-value" id="peer-count">0</div>
          <div class="stat-verify" id="peer-verify">Waiting...</div>
        </div>
        <div class="stat-box">
          <div class="stat-label">Total Fragments</div>
          <div class="stat-value" id="frag-total">0</div>
          <div class="stat-verify" id="frag-verify">P2P:0 HTTP:0</div>
        </div>
      </div>

      <div class="verification" id="verification-status">
        <strong>‚úÖ Verification Status:</strong> Waiting to start...
      </div>

      <h3>üîç Detailed Download Log</h3>
      <div class="log" id="log"></div>
    </div>

  </div>

  <!-- HLS.js from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/hls.js@1.5.13/dist/hls.min.js"></script>
  
  <!-- Import map for local v2.2.1 files -->
  <script type="importmap">
  {
    "imports": {
      "p2p-media-loader-core": "./lib/p2p-media-loader-core.min.js",
      "p2p-media-loader-hlsjs": "./lib/p2p-media-loader-hlsjs.min.js"
    }
  }
  </script>
  
  <!-- P2P Media Loader v2.2.1 -->
  <script type="module">
    import { HlsJsP2PEngine } from 'p2p-media-loader-hlsjs';

    // Triple-verification tracking
    const tracking = {
      // Method 1: onChunkDownloaded (has downloadSource parameter)
      method1_p2p: 0,
      method1_http: 0,
      method1_p2pCount: 0,
      method1_httpCount: 0,
      
      // Method 2: onSegmentLoaded (has peerId to determine source)
      method2_p2p: 0,
      method2_http: 0,
      method2_p2pCount: 0,
      method2_httpCount: 0,
      
      // Method 3: HLS.js FRAG_LOADED (what HLS.js sees)
      method3_total: 0,
      method3_count: 0,
      
      // Peer tracking
      peers: new Set(),
      
      // Fragment details for verification
      fragments: []
    };

    let hls = null;
    let p2pEngine = null;

    // Logging with categories
    function log(message, type = 'info') {
      const now = new Date();
      const time = now.toLocaleTimeString() + '.' + now.getMilliseconds().toString().padStart(3, '0');
      
      const entry = document.createElement('div');
      entry.className = `log-entry log-${type}`;
      entry.innerHTML = `<span class="log-time">${time}</span><span>${message}</span>`;
      
      const logPanel = document.getElementById('log');
      logPanel.appendChild(entry);
      logPanel.scrollTop = logPanel.scrollHeight;
      
      while (logPanel.children.length > 200) {
        logPanel.removeChild(logPanel.firstChild);
      }
      
      console.log(`[${type.toUpperCase()}] ${time}:`, message);
    }

    // Update verification status
    function updateVerification() {
      const statusDiv = document.getElementById('verification-status');
      const p2pBox = document.getElementById('p2p-box');
      const httpBox = document.getElementById('http-box');
      
      // Check if methods agree
      const method1Total = tracking.method1_p2p + tracking.method1_http;
      const method2Total = tracking.method2_p2p + tracking.method2_http;
      const method3Total = tracking.method3_total;
      
      const p2pMatch = Math.abs(tracking.method1_p2p - tracking.method2_p2p) < 1000; // Within 1KB
      const httpMatch = Math.abs(tracking.method1_http - tracking.method2_http) < 1000;
      const totalMatch = Math.abs(method1Total - method3Total) < 1000;
      
      let status = '';
      let hasError = false;
      
      if (method1Total === 0) {
        status = '‚è≥ Waiting for downloads...';
      } else {
        status = '<strong>Verification Results:</strong><br>';
        
        // P2P verification
        if (p2pMatch) {
          status += `‚úÖ P2P bytes: Method1=${(tracking.method1_p2p/1024/1024).toFixed(2)}MB, Method2=${(tracking.method2_p2p/1024/1024).toFixed(2)}MB (MATCH)<br>`;
          p2pBox.classList.remove('mismatch');
        } else {
          status += `‚ùå P2P MISMATCH: Method1=${(tracking.method1_p2p/1024/1024).toFixed(2)}MB vs Method2=${(tracking.method2_p2p/1024/1024).toFixed(2)}MB<br>`;
          p2pBox.classList.add('mismatch');
          hasError = true;
        }
        
        // HTTP verification
        if (httpMatch) {
          status += `‚úÖ HTTP bytes: Method1=${(tracking.method1_http/1024/1024).toFixed(2)}MB, Method2=${(tracking.method2_http/1024/1024).toFixed(2)}MB (MATCH)<br>`;
          httpBox.classList.remove('mismatch');
        } else {
          status += `‚ùå HTTP MISMATCH: Method1=${(tracking.method1_http/1024/1024).toFixed(2)}MB vs Method2=${(tracking.method2_http/1024/1024).toFixed(2)}MB<br>`;
          httpBox.classList.add('mismatch');
          hasError = true;
        }
        
        // Total verification
        if (totalMatch) {
          status += `‚úÖ Total: ${(method1Total/1024/1024).toFixed(2)}MB (P2P+HTTP matches HLS.js total: ${(method3Total/1024/1024).toFixed(2)}MB)<br>`;
        } else {
          status += `‚ö†Ô∏è Total discrepancy: P2P+HTTP=${(method1Total/1024/1024).toFixed(2)}MB vs HLS.js=${(method3Total/1024/1024).toFixed(2)}MB (Diff: ${((method1Total-method3Total)/1024/1024).toFixed(2)}MB)<br>`;
          hasError = true;
        }
        
        // Fragment count verification
        const fragMatch = tracking.method1_p2pCount + tracking.method1_httpCount === tracking.method3_count;
        if (fragMatch) {
          status += `‚úÖ Fragments: ${tracking.method3_count} total (P2P:${tracking.method1_p2pCount} + HTTP:${tracking.method1_httpCount})<br>`;
        } else {
          status += `‚ùå Fragment count mismatch: P2P(${tracking.method1_p2pCount}) + HTTP(${tracking.method1_httpCount}) = ${tracking.method1_p2pCount + tracking.method1_httpCount} vs HLS.js(${tracking.method3_count})<br>`;
          hasError = true;
        }
      }
      
      statusDiv.innerHTML = status;
      statusDiv.className = hasError ? 'verification error' : 'verification';
    }

    // Update stats display
    function updateStats() {
      // Use Method 1 (onChunkDownloaded) as primary source since it has downloadSource parameter
      const p2pMB = tracking.method1_p2p / 1024 / 1024;
      const httpMB = tracking.method1_http / 1024 / 1024;
      const total = p2pMB + httpMB;
      const ratio = total > 0 ? (p2pMB / total * 100) : 0;
      
      document.getElementById('p2p-mb').textContent = p2pMB.toFixed(2) + ' MB';
      document.getElementById('http-mb').textContent = httpMB.toFixed(2) + ' MB';
      document.getElementById('p2p-ratio').textContent = ratio.toFixed(1) + '%';
      document.getElementById('peer-count').textContent = tracking.peers.size;
      document.getElementById('frag-total').textContent = tracking.method3_count;
      
      // Show verification details
      document.getElementById('p2p-verify').textContent = `M1:${tracking.method1_p2pCount} M2:${tracking.method2_p2pCount}`;
      document.getElementById('http-verify').textContent = `M1:${tracking.method1_httpCount} M2:${tracking.method2_httpCount}`;
      document.getElementById('ratio-verify').textContent = `${tracking.method1_p2pCount} P2P / ${tracking.method3_count} total`;
      document.getElementById('peer-verify').textContent = `IDs: ${Array.from(tracking.peers).slice(0, 2).join(', ')}`;
      document.getElementById('frag-verify').textContent = `P2P:${tracking.method1_p2pCount} HTTP:${tracking.method1_httpCount}`;
      
      updateVerification();
    }

    // Play Stream
    window.playStream = function() {
      const url = 'https://test-streams.mux.dev/x36xhzz/x36xhzz.m3u8';
      
      log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'info');
      log('üî¨ Starting TRIPLE-VERIFIED P2P test with v2.2.1', 'info');
      log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'info');
      
      const video = document.getElementById('video');

      if (!Hls.isSupported()) {
        log('‚ùå HLS.js not supported', 'error');
        return;
      }

      if (typeof HlsJsP2PEngine === 'undefined') {
        log('‚ùå P2P Media Loader not loaded', 'error');
        return;
      }

      try {
        log('‚úÖ Creating HLS with P2P configuration...', 'info');
        
        const p2pConfig = {
          core: {
            swarmId: url,
            announceTrackers: [
              'wss://tracker.openwebtorrent.com',
              'wss://tracker.webtorrent.dev',
              'wss://tracker.fastcast.nz'
            ]
          },
          onHlsJsCreated(hlsWithP2P) {
            log('‚úÖ HLS.js created with P2P', 'info');
            
            p2pEngine = hlsWithP2P.p2pEngine;
            if (!p2pEngine) {
              log('‚ùå P2P engine not accessible', 'error');
              return;
            }

            log('‚úÖ P2P Engine accessible, setting up TRIPLE verification...', 'info');
            
            // METHOD 1: onChunkDownloaded - Has downloadSource parameter (PRIMARY SOURCE)
            p2pEngine.addEventListener('onChunkDownloaded', (bytesLength, downloadSource, peerId) => {
              if (downloadSource === 'p2p') {
                tracking.method1_p2p += bytesLength;
                tracking.method1_p2pCount++;
                log(`üì• [M1] P2P chunk: ${(bytesLength/1024).toFixed(2)}KB from peer ${peerId} | Total P2P: ${(tracking.method1_p2p/1024/1024).toFixed(2)}MB`, 'verify');
              } else if (downloadSource === 'http') {
                tracking.method1_http += bytesLength;
                tracking.method1_httpCount++;
                log(`üì° [M1] HTTP chunk: ${(bytesLength/1024).toFixed(2)}KB | Total HTTP: ${(tracking.method1_http/1024/1024).toFixed(2)}MB`, 'verify');
              }
              updateStats();
            });
            
            // METHOD 2: onSegmentLoaded - Has peerId to determine source (SECONDARY VERIFICATION)
            p2pEngine.addEventListener('onSegmentLoaded', (details) => {
              const bytes = details.data?.byteLength || 0;
              if (details.peerId) {
                tracking.method2_p2p += bytes;
                tracking.method2_p2pCount++;
                log(`üì• [M2] Segment from P2P: ${(bytes/1024).toFixed(2)}KB (peer: ${details.peerId})`, 'verify');
              } else {
                tracking.method2_http += bytes;
                tracking.method2_httpCount++;
                log(`üì° [M2] Segment from HTTP: ${(bytes/1024).toFixed(2)}KB`, 'verify');
              }
              updateStats();
            });
            
            // Peer tracking
            p2pEngine.addEventListener('onPeerConnect', (details) => {
              tracking.peers.add(details.peerId);
              log(`ü§ù Peer connected: ${details.peerId} | Total peers: ${tracking.peers.size}`, 'info');
              updateStats();
            });
            
            p2pEngine.addEventListener('onPeerClose', (details) => {
              tracking.peers.delete(details.peerId);
              log(`üëã Peer disconnected: ${details.peerId} | Remaining: ${tracking.peers.size}`, 'info');
              updateStats();
            });
            
            // Error tracking
            p2pEngine.addEventListener('onSegmentError', (details) => {
              log(`‚ùå Segment error: ${details.error?.message || 'unknown'}`, 'error');
            });
            
            p2pEngine.addEventListener('onPeerError', (details) => {
              log(`‚ùå Peer error: ${details.peerId} - ${details.error?.message || 'unknown'}`, 'error');
            });
            
            p2pEngine.addEventListener('onTrackerError', (details) => {
              log(`‚ùå Tracker error: ${details.error?.message || 'unknown'}`, 'error');
            });

            log('‚úÖ All verification event listeners registered', 'info');
          }
        };
        
        // Create HLS instance
        hls = new Hls({
          liveSyncDuration: 3,
          liveMaxLatencyDuration: 10,
          lowLatencyMode: true,
          p2p: p2pConfig
        });
        
        // METHOD 3: HLS.js FRAG_LOADED - What HLS.js sees (SANITY CHECK)
        hls.on(Hls.Events.FRAG_LOADED, (event, data) => {
          const bytes = data.stats?.total || data.frag?.stats?.total || 0;
          tracking.method3_total += bytes;
          tracking.method3_count++;
          log(`üìä [M3-HLS.js] Fragment ${data.frag.sn}: ${(bytes/1024).toFixed(2)}KB | HLS.js total: ${(tracking.method3_total/1024/1024).toFixed(2)}MB`, 'verify');
          updateStats();
        });
        
        hls.on(Hls.Events.MANIFEST_PARSED, () => {
          log('‚úÖ Manifest loaded, starting playback', 'info');
          video.play().catch(err => {
            log(`‚ö†Ô∏è Autoplay blocked: ${err.message}`, 'warn');
          });
        });
        
        hls.on(Hls.Events.ERROR, (event, data) => {
          if (data.fatal) {
            log(`‚ùå Fatal HLS error: ${data.type} - ${data.details}`, 'error');
          }
        });

        hls.loadSource(url);
        hls.attachMedia(video);
        
        log('üí° Open 2-3 more tabs to see P2P peer connections!', 'info');
        log('üîç Watch for [M1], [M2], [M3] log prefixes showing triple verification', 'info');

      } catch (err) {
        log(`‚ùå Error: ${err.message}`, 'error');
        console.error('Full error:', err);
      }
    };

    // Stop Stream
    window.stopStream = function() {
      if (hls) {
        hls.destroy();
        hls = null;
      }
      
      if (p2pEngine && p2pEngine.destroy) {
        p2pEngine.destroy();
        p2pEngine = null;
      }
      
      const video = document.getElementById('video');
      video.pause();
      video.src = '';
      
      log('‚èπÔ∏è Stream stopped', 'info');
      log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'info');
      log('üìä Final Verification Summary:', 'info');
      log(`   Method 1 (onChunkDownloaded): P2P=${(tracking.method1_p2p/1024/1024).toFixed(2)}MB, HTTP=${(tracking.method1_http/1024/1024).toFixed(2)}MB`, 'verify');
      log(`   Method 2 (onSegmentLoaded): P2P=${(tracking.method2_p2p/1024/1024).toFixed(2)}MB, HTTP=${(tracking.method2_http/1024/1024).toFixed(2)}MB`, 'verify');
      log(`   Method 3 (HLS.js FRAG_LOADED): Total=${(tracking.method3_total/1024/1024).toFixed(2)}MB`, 'verify');
      log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'info');
    };

    // Initialize
    window.addEventListener('DOMContentLoaded', () => {
      log('üöÄ Triple-Verified P2P Tester Ready!', 'info');
      log('‚úÖ HLS.js v1.5.13 loaded', 'info');
      log('‚úÖ P2P Media Loader v2.2.1 loaded (local)', 'info');
      log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'info');
      log('üî¨ This page uses 3 verification methods:', 'info');
      log('   M1: onChunkDownloaded (primary - has downloadSource)', 'info');
      log('   M2: onSegmentLoaded (secondary - has peerId)', 'info');
      log('   M3: HLS.js FRAG_LOADED (sanity check - total)', 'info');
      log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'info');
    });
  </script>
</body>
</html>

