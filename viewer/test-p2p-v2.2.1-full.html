<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>P2P HLS Test v2.2.1 (Full Debug) - Fire TV / Android TV</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #0b0f14;
      color: #e6eef7;
      padding: 20px;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    h1 {
      text-align: center;
      margin-bottom: 10px;
      font-size: 2rem;
      background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .subtitle {
      text-align: center;
      color: #888;
      margin-bottom: 30px;
    }

    .device-info {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 20px;
      font-size: 0.9rem;
    }

    .device-info strong {
      color: #4ecdc4;
    }

    .test-section {
      background: #101826;
      border: 1px solid #223040;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
    }

    h2 {
      color: #4ecdc4;
      margin-bottom: 15px;
    }

    .input-group {
      margin: 15px 0;
    }

    label {
      display: block;
      margin-bottom: 5px;
      color: #aaa;
      font-size: 0.9rem;
    }

    input[type="text"] {
      width: 100%;
      padding: 10px;
      background: #0b0f14;
      border: 2px solid #223040;
      border-radius: 6px;
      color: #fff;
      font-size: 1rem;
      font-family: monospace;
    }

    input[type="text"]:focus {
      outline: none;
      border-color: #4ecdc4;
    }

    button {
      background: #4ecdc4;
      color: #000;
      border: none;
      padding: 12px 24px;
      font-size: 1.1rem;
      font-weight: 600;
      border-radius: 8px;
      cursor: pointer;
      margin: 10px 10px 10px 0;
      transition: transform 0.1s;
    }

    button:hover {
      transform: scale(1.05);
    }

    button:active {
      transform: scale(0.95);
    }

    .preset-btn {
      background: #223040;
      color: #fff;
      padding: 8px 16px;
      font-size: 0.9rem;
    }

    .preset-btn:hover {
      background: #2a3a4b;
    }

    .video-container {
      position: relative;
      background: #000;
      border-radius: 8px;
      overflow: hidden;
      margin: 15px 0;
      aspect-ratio: 16/9;
    }

    video {
      width: 100%;
      height: 100%;
      display: block;
      object-fit: contain;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 10px;
      margin: 15px 0;
    }

    .stat-box {
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid #223040;
      border-radius: 6px;
      padding: 10px;
      text-align: center;
    }

    .stat-label {
      color: #888;
      font-size: 0.8rem;
      margin-bottom: 5px;
    }

    .stat-value {
      color: #4ecdc4;
      font-size: 1.4rem;
      font-weight: 600;
    }

    .log {
      background: #000;
      border: 1px solid #223040;
      border-radius: 6px;
      padding: 15px;
      max-height: 300px;
      overflow-y: auto;
      font-family: 'Courier New', monospace;
      font-size: 0.85rem;
      margin-top: 15px;
    }

    .log-entry {
      padding: 2px 0;
      border-bottom: 1px solid #111;
    }

    .log-time { color: #666; margin-right: 10px; }
    .log-info { color: #4ecdc4; }
    .log-warn { color: #ffa600; }
    .log-error { color: #ff6b6b; }
  </style>
</head>
<body>
  <div class="container">
    <h1>üåê P2P HLS Test v2.2.1 (Full Debug)</h1>
    <p class="subtitle">Using p2p-media-loader v2.2.1 with comprehensive debugging</p>

    <!-- Device Info -->
    <div class="device-info" id="device-info">
      <strong>Device:</strong> <span id="device-name">Detecting...</span><br>
      <strong>Browser:</strong> <span id="browser-name">Detecting...</span><br>
      <strong>P2P Support:</strong> <span id="p2p-support">Checking...</span><br>
      <strong>HLS.js:</strong> <span id="hls-support">Checking...</span><br>
      <strong>Debug:</strong> <span id="debug-info" style="color: #888;">Loading...</span>
    </div>

    <!-- HLS Test Section -->
    <div class="test-section">
      <h2>üì∫ P2P HLS Live Stream Test</h2>
      
      <p style="margin-bottom: 15px; color: #aaa;">
        Test P2P-accelerated HLS streaming with v2.2.1. <strong>HTTP fallback works automatically!</strong>
      </p>
      
      <div class="input-group">
        <label for="hls-url">HLS Stream URL (.m3u8):</label>
        <input type="text" id="hls-url" value="https://test-streams.mux.dev/x36xhzz/x36xhzz.m3u8" placeholder="https://example.com/stream.m3u8">
      </div>

      <div style="display: flex; flex-wrap: wrap; gap: 10px; margin: 10px 0;">
        <button class="preset-btn" onclick="setPreset('mux')">Mux Test Stream</button>
        <button class="preset-btn" onclick="setPreset('big-buck')">Big Buck Bunny</button>
        <button class="preset-btn" onclick="setPreset('custom')">Custom URL</button>
      </div>

      <button onclick="playStream()">‚ñ∂Ô∏è Play with P2P</button>
      <button onclick="stopStream()">‚èπÔ∏è Stop</button>

      <div class="video-container">
        <video id="video" controls playsinline></video>
      </div>

      <div class="stats-grid">
        <div class="stat-box">
          <div class="stat-label">P2P Peers</div>
          <div class="stat-value" id="peer-count">0</div>
        </div>
        <div class="stat-box">
          <div class="stat-label">P2P Downloaded</div>
          <div class="stat-value" id="p2p-downloaded">0 MB</div>
        </div>
        <div class="stat-box">
          <div class="stat-label">HTTP Downloaded</div>
          <div class="stat-value" id="http-downloaded">0 MB</div>
        </div>
        <div class="stat-box">
          <div class="stat-label">P2P Ratio</div>
          <div class="stat-value" id="p2p-ratio">0%</div>
        </div>
        <div class="stat-box">
          <div class="stat-label">Buffer</div>
          <div class="stat-value" id="buffer">0s</div>
        </div>
        <div class="stat-box">
          <div class="stat-label">Latency</div>
          <div class="stat-value" id="latency">--</div>
        </div>
      </div>

      <div class="log" id="log"></div>
    </div>

  </div>

  <!-- HLS.js from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/hls.js@1.5.13/dist/hls.min.js"></script>
  
  <!-- Import map for local v2.2.1 files -->
  <script type="importmap">
  {
    "imports": {
      "p2p-media-loader-core": "./lib/p2p-media-loader-core.min.js",
      "p2p-media-loader-hlsjs": "./lib/p2p-media-loader-hlsjs.min.js"
    }
  }
  </script>
  
  <!-- P2P Media Loader v2.2.1 - LOCAL FILES -->
  <script type="module">
    import { HlsJsP2PEngine } from 'p2p-media-loader-hlsjs';

    // State
    let hls = null;
    let p2pEngine = null;
    let statsInterval = null;
    let peerIds = new Set();
    
    const stats = {
      p2pDownloaded: 0,
      httpDownloaded: 0,
      p2pUploaded: 0,
      peers: 0
    };

    // Logging
    function log(message, type = 'info') {
      const now = new Date();
      const time = now.toLocaleTimeString();
      
      const entry = document.createElement('div');
      entry.className = `log-entry log-${type}`;
      entry.innerHTML = `<span class="log-time">${time}</span><span>${message}</span>`;
      
      const logPanel = document.getElementById('log');
      logPanel.appendChild(entry);
      logPanel.scrollTop = logPanel.scrollHeight;
      
      while (logPanel.children.length > 100) {
        logPanel.removeChild(logPanel.firstChild);
      }
      
      console.log(`[${type.toUpperCase()}]`, message);
    }

    // Device Detection
    function detectDevice() {
      const ua = navigator.userAgent;
      let device = 'Unknown';
      let browser = 'Unknown';

      if (/AFTM|AFTT|AFTS|AFTB/.test(ua)) {
        device = 'Amazon Fire TV';
      } else if (/Android.*TV/.test(ua)) {
        device = 'Android TV';
      } else if (/Android/.test(ua)) {
        device = 'Android Mobile';
      } else if (/iPhone|iPad|iPod/.test(ua)) {
        device = 'iOS Device';
      } else if (/Mac/.test(ua)) {
        device = 'macOS';
      } else if (/Windows/.test(ua)) {
        device = 'Windows PC';
      } else if (/Linux/.test(ua)) {
        device = 'Linux';
      }

      if (/Silk/.test(ua)) {
        browser = 'Amazon Silk';
      } else if (/Chrome/.test(ua) && !/Edge/.test(ua)) {
        browser = 'Chrome';
      } else if (/Safari/.test(ua) && !/Chrome/.test(ua)) {
        browser = 'Safari';
      } else if (/Firefox/.test(ua)) {
        browser = 'Firefox';
      } else if (/Edge/.test(ua)) {
        browser = 'Edge';
      }

      document.getElementById('device-name').textContent = device;
      document.getElementById('browser-name').textContent = browser;

      // Check support
      const webrtcSupported = !!(window.RTCPeerConnection || window.webkitRTCPeerConnection);
      const hlsSupported = typeof Hls !== 'undefined' && Hls.isSupported();
      const p2pSupported = typeof HlsJsP2PEngine !== 'undefined';

      document.getElementById('p2p-support').textContent = webrtcSupported && p2pSupported ? '‚úÖ Supported' : '‚ùå Not Supported';
      document.getElementById('p2p-support').style.color = webrtcSupported && p2pSupported ? '#4ecdc4' : '#ff6b6b';
      
      document.getElementById('hls-support').textContent = hlsSupported ? '‚úÖ Loaded' : '‚ùå Not Available';
      document.getElementById('hls-support').style.color = hlsSupported ? '#4ecdc4' : '#ff6b6b';

      document.getElementById('debug-info').textContent = 
        `WebRTC:${webrtcSupported} HLS:${hlsSupported} P2P:${p2pSupported}`;
      document.getElementById('debug-info').style.color = webrtcSupported && hlsSupported ? '#4ecdc4' : '#ffa600';
    }

    // Presets
    window.setPreset = function(preset) {
      const presets = {
        'mux': 'https://test-streams.mux.dev/x36xhzz/x36xhzz.m3u8',
        'big-buck': 'https://test-streams.mux.dev/x36xhzz/url_6/193039199_mp4_h264_aac_hq_7.m3u8',
      };
      if (preset !== 'custom' && presets[preset]) {
        document.getElementById('hls-url').value = presets[preset];
      }
    };

    // Play Stream
    window.playStream = function() {
      const url = document.getElementById('hls-url').value.trim();
      
      if (!url) {
        log('‚ùå Please enter an HLS URL', 'error');
        return;
      }

      if (!Hls.isSupported()) {
        log('‚ùå HLS.js not supported on this browser', 'error');
        return;
      }

      log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'info');
      log('üé¨ Starting P2P HLS playback with v2.2.1...', 'info');
      log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'info');
      
      const video = document.getElementById('video');

      if (typeof HlsJsP2PEngine === 'undefined') {
        log('‚ö†Ô∏è P2P Media Loader v2.2.1 not available, using HLS.js only', 'warn');
        playWithoutP2P(url, video);
        return;
      }

      try {
        log(`‚úÖ P2P Media Loader v2.2.1 detected!`, 'info');
        
        // P2P configuration (BangstreamPro pattern - pass directly to HLS)
        const p2pConfig = {
          core: {
            swarmId: url,
            announceTrackers: [
              'wss://tracker.openwebtorrent.com',
              'wss://tracker.webtorrent.dev',
              'wss://tracker.fastcast.nz',
              'wss://tracker.btorrent.xyz'
            ],
            rtcConfig: {
              iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:global.stun.twilio.com:3478' }
              ]
            }
          },
          onHlsJsCreated(hlsWithP2P) {
            // Access P2P engine after HLS is fully initialized (BangstreamPro pattern)
            log('‚úÖ HLS instance created with P2P', 'info');
            
            p2pEngine = hlsWithP2P.p2pEngine;
            if (!p2pEngine) {
              log('‚ö†Ô∏è Could not access P2P engine', 'warn');
              return;
            }

            log('‚úÖ P2P Engine accessible, setting up event listeners...', 'info');
            
            // Use Event enum if available, otherwise use strings
            const Events = HlsJsP2PEngine.Events || {};
            
            // Peer connection events
            p2pEngine.on(Events.PeerConnect || 'peer_connect', (peerId) => {
              peerIds.add(peerId);
              stats.peers = peerIds.size;
              log(`ü§ù Peer connected! ID: ${peerId} (Total: ${stats.peers})`, 'info');
              updateStats();
            });
            
            p2pEngine.on(Events.PeerClose || 'peer_close', (peerId) => {
              peerIds.delete(peerId);
              stats.peers = peerIds.size;
              log(`üëã Peer disconnected: ${peerId} (Total: ${stats.peers})`, 'info');
              updateStats();
            });
            
            // Bandwidth tracking
            p2pEngine.on(Events.PieceBytesDownloaded || 'piece_bytes_downloaded', (bytes) => {
              stats.p2pDownloaded += bytes;
              updateStats();
            });
            
            p2pEngine.on(Events.PieceBytesUploaded || 'piece_bytes_uploaded', (bytes) => {
              stats.p2pUploaded += bytes;
              updateStats();
            });
            
            // CRITICAL: Tracker events for debugging
            p2pEngine.on(Events.TrackerAnnounce || 'tracker_announce', (tracker) => {
              log(`üì¢ TRACKER ANNOUNCE: ${tracker?.url || tracker}`, 'info');
            });
            
            p2pEngine.on(Events.TrackerUpdate || 'tracker_update', (data) => {
              const peerCount = data?.peers?.length || 0;
              log(`üìä TRACKER UPDATE: ${peerCount} peer(s) available`, 'info');
              if (peerCount > 0 && data?.peers) {
                log(`   Peers: ${JSON.stringify(data.peers.slice(0, 3))}${peerCount > 3 ? '...' : ''}`, 'info');
              }
            });
            
            p2pEngine.on(Events.TrackerError || 'tracker_error', (error) => {
              log(`‚ùå TRACKER ERROR: ${error?.message || JSON.stringify(error)}`, 'error');
            });
            
            p2pEngine.on(Events.TrackerWarning || 'tracker_warning', (warning) => {
              log(`‚ö†Ô∏è TRACKER WARNING: ${warning?.message || JSON.stringify(warning)}`, 'warn');
            });
            
            // Peer errors
            p2pEngine.on(Events.PeerError || 'peer_error', (error) => {
              log(`‚ùå PEER ERROR: ${error?.message || JSON.stringify(error)}`, 'error');
            });
            
            // Segment events
            p2pEngine.on(Events.SegmentLoaded || 'segment_loaded', (segment, peerId) => {
              if (peerId) {
                log(`üì• P2P: Segment loaded from peer ${peerId}`, 'info');
              } else {
                log(`üì° HTTP: Segment loaded via fallback`, 'info');
              }
            });
            
            p2pEngine.on(Events.SegmentError || 'segment_error', (error) => {
              log(`‚ùå SEGMENT ERROR: ${error?.message || JSON.stringify(error)}`, 'error');
            });

            log('‚úÖ All P2P event listeners registered', 'info');
          }
        };
        
        log(`üîß P2P Config:`, 'info');
        log(`  - Swarm ID: ${url.substring(0, 60)}...`, 'info');
        log(`  - Trackers: ${p2pConfig.core.announceTrackers.length}`, 'info');
        p2pConfig.core.announceTrackers.forEach(t => log(`    ‚Ä¢ ${t}`, 'info'));
        
        // Create HLS with P2P (BangstreamPro pattern - config passed directly)
        log(`üîß Creating HLS.js instance with P2P config...`, 'info');
        hls = new Hls({
          liveSyncDuration: 3,
          liveMaxLatencyDuration: 10,
          backBufferLength: 30,
          maxBufferLength: 30,
          lowLatencyMode: true,
          p2p: p2pConfig  // Pass P2P config directly (BangstreamPro pattern)
        });
        
        log('‚úÖ HLS instance created', 'info');
        
        // HLS event listeners
        hls.on(Hls.Events.MANIFEST_PARSED, () => {
          log('‚úÖ Manifest parsed successfully', 'info');
          video.play().catch(err => {
            log(`‚ö†Ô∏è Autoplay blocked: ${err.message}. Click video to play.`, 'warn');
          });
        });
        
        hls.on(Hls.Events.FRAG_LOADING, (event, data) => {
          log(`üîÑ HLS: Loading fragment ${data.frag.sn}`, 'info');
        });
        
        hls.on(Hls.Events.FRAG_LOADED, (event, data) => {
          const size = data.stats?.total || data.frag?.stats?.total || 0;
          log(`‚úÖ HLS: Fragment ${data.frag.sn} loaded (${(size / 1024).toFixed(2)} KB)`, 'info');
          // Note: We track HTTP separately via segment_loaded events, not FRAG_LOADED
        });

        hls.on(Hls.Events.ERROR, (event, data) => {
          if (data.fatal) {
            log(`‚ùå Fatal HLS error: ${data.type} - ${data.details}`, 'error');
            
            switch(data.type) {
              case Hls.ErrorTypes.NETWORK_ERROR:
                log('‚ö†Ô∏è Attempting to recover from network error...', 'warn');
                hls.startLoad();
                break;
              case Hls.ErrorTypes.MEDIA_ERROR:
                log('‚ö†Ô∏è Attempting to recover from media error...', 'warn');
                hls.recoverMediaError();
                break;
              default:
                log('‚ùå Cannot recover, destroying HLS instance', 'error');
                stopStream();
                break;
            }
          } else {
            if (data.details === 'internalException') {
              log(`‚ö†Ô∏è HLS internalException`, 'warn');
              if (data.error) {
                log(`   Exception: ${data.error.message || data.error}`, 'error');
              }
            } else {
              log(`‚ö†Ô∏è HLS: ${data.details}`, 'warn');
            }
          }
        });

        // Load and play
        hls.loadSource(url);
        hls.attachMedia(video);
        
        log('‚ñ∂Ô∏è Stream starting...', 'info');
        log('üí° Open this page in 2-3+ tabs to see P2P peers connect!', 'info');

        // Start stats updates
        statsInterval = setInterval(updateStats, 1000);

        // Periodic diagnostics
        let diagnosticCount = 0;
        const diagnosticInterval = setInterval(() => {
          diagnosticCount++;
          if (diagnosticCount % 10 === 0) {
            const peerCount = stats.peers;
            if (peerCount === 0) {
              log(`‚ö†Ô∏è No peers yet. HTTP fallback working!`, 'warn');
              log(`üí° Open more tabs to see P2P sharing`, 'info');
            } else {
              log(`üìä P2P Active: ${peerCount} peer(s), ${(stats.p2pDownloaded / 1024 / 1024).toFixed(2)} MB via P2P`, 'info');
            }
          }
        }, 1000);

        // Clean up on stop
        const originalStop = window.stopStream;
        window.stopStream = function() {
          clearInterval(diagnosticInterval);
          originalStop();
        };

      } catch (err) {
        log(`‚ùå Error initializing P2P: ${err.message}`, 'error');
        console.error('Full error:', err);
        playWithoutP2P(url, video);
      }
    };

    // Fallback without P2P
    function playWithoutP2P(url, video) {
      log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'warn');
      log('‚ö†Ô∏è Running in HTTP-only mode (no P2P)', 'warn');
      log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'warn');

      hls = new Hls({
        liveSyncDuration: 3,
        liveMaxLatencyDuration: 10,
        lowLatencyMode: true,
      });

      hls.on(Hls.Events.MANIFEST_PARSED, () => {
        log('‚úÖ Manifest loaded (HTTP only)', 'info');
        video.play();
      });

      hls.on(Hls.Events.FRAG_LOADED, (event, data) => {
        stats.httpDownloaded += data.frag?.stats?.total || 0;
        log(`üì° HTTP: Fragment ${data.frag.sn} loaded`, 'info');
        updateStats();
      });

      hls.on(Hls.Events.ERROR, (event, data) => {
        if (data.fatal) {
          log(`‚ùå HLS error: ${data.details}`, 'error');
        }
      });

      hls.loadSource(url);
      hls.attachMedia(video);

      statsInterval = setInterval(updateStats, 1000);
    }

    // Stop Stream
    window.stopStream = function() {
      if (hls) {
        hls.destroy();
        hls = null;
      }
      
      if (p2pEngine && p2pEngine.destroy) {
        p2pEngine.destroy();
        p2pEngine = null;
      }
      
      if (statsInterval) {
        clearInterval(statsInterval);
        statsInterval = null;
      }
      
      const video = document.getElementById('video');
      video.pause();
      video.src = '';
      
      stats.p2pDownloaded = 0;
      stats.httpDownloaded = 0;
      stats.p2pUploaded = 0;
      stats.peers = 0;
      peerIds.clear();
      
      updateStats();
      
      log('‚èπÔ∏è Stream stopped', 'info');
    };

    // Update Stats
    function updateStats() {
      document.getElementById('peer-count').textContent = stats.peers;
      document.getElementById('p2p-downloaded').textContent = (stats.p2pDownloaded / 1024 / 1024).toFixed(2) + ' MB';
      document.getElementById('http-downloaded').textContent = (stats.httpDownloaded / 1024 / 1024).toFixed(2) + ' MB';
      
      const total = stats.p2pDownloaded + stats.httpDownloaded;
      const p2pRatio = total > 0 ? (stats.p2pDownloaded / total * 100) : 0;
      document.getElementById('p2p-ratio').textContent = p2pRatio.toFixed(0) + '%';
      
      const video = document.getElementById('video');
      if (video.buffered.length > 0) {
        const buffered = video.buffered.end(0) - video.currentTime;
        document.getElementById('buffer').textContent = buffered.toFixed(1) + 's';
      }
      
      if (hls && hls.latency) {
        document.getElementById('latency').textContent = hls.latency.toFixed(1) + 's';
      }
    }

    // Initialize
    window.addEventListener('DOMContentLoaded', () => {
      detectDevice();
      log('üöÄ P2P HLS v2.2.1 Tester Ready!', 'info');
      log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'info');
      
      // Check if libraries loaded
      setTimeout(() => {
        if (typeof Hls === 'undefined') {
          log('‚ùå HLS.js failed to load', 'error');
        } else {
          log('‚úÖ HLS.js v1.5.13 loaded', 'info');
        }
        
        if (typeof HlsJsP2PEngine === 'undefined') {
          log('‚ùå P2P Media Loader failed to load', 'error');
        } else {
          log('‚úÖ P2P Media Loader v2.2.1 loaded (local files)', 'info');
          log(`  Available Events: ${Object.keys(HlsJsP2PEngine.Events || {}).length}`, 'info');
        }
        
        // WebRTC check
        if (!window.RTCPeerConnection) {
          log('‚ùå WebRTC not available - P2P will not work', 'error');
        } else {
          log('‚úÖ WebRTC available', 'info');
        }
        
        log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'info');
        log('üí° P2P requires 2+ viewers on the same stream', 'info');
        log('üí° HTTP fallback works automatically with 0 peers!', 'info');
        log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'info');
        
        // Test WebRTC connectivity
        log('üîç Testing WebRTC connectivity...', 'info');
        try {
          const pc = new RTCPeerConnection({
            iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
          });
          
          pc.createDataChannel('test');
          pc.createOffer().then(offer => pc.setLocalDescription(offer)).then(() => {
            log('‚úÖ WebRTC: Can create offers and data channels', 'info');
            
            let candidateCount = 0;
            pc.onicecandidate = (event) => {
              if (event.candidate) {
                candidateCount++;
                if (candidateCount === 1) {
                  log(`‚úÖ WebRTC: ICE candidates OK (${event.candidate.type})`, 'info');
                }
              } else if (candidateCount > 0) {
                log(`‚úÖ WebRTC: ${candidateCount} ICE candidates generated`, 'info');
              } else {
                log(`‚ö†Ô∏è WebRTC: No ICE candidates - firewall may block P2P`, 'warn');
              }
            };
            
            setTimeout(() => pc.close(), 3000);
          }).catch(err => {
            log(`‚ùå WebRTC test failed: ${err.message}`, 'error');
          });
        } catch(e) {
          log(`‚ùå WebRTC test error: ${e.message}`, 'error');
        }
        
        // Test tracker connectivity
        log('üîç Testing tracker connectivity...', 'info');
        const testTrackers = [
          'wss://tracker.openwebtorrent.com',
          'wss://tracker.webtorrent.dev'
        ];
        
        testTrackers.forEach(tracker => {
          try {
            const ws = new WebSocket(tracker);
            const timeout = setTimeout(() => {
              if (ws.readyState !== WebSocket.OPEN) {
                log(`‚ö†Ô∏è Tracker timeout: ${tracker}`, 'warn');
                ws.close();
              }
            }, 5000);
            
            ws.onopen = () => {
              clearTimeout(timeout);
              log(`‚úÖ Tracker OK: ${tracker}`, 'info');
              ws.close();
            };
            
            ws.onerror = () => {
              clearTimeout(timeout);
              log(`‚ùå Tracker error: ${tracker}`, 'error');
            };
          } catch(e) {
            log(`‚ùå Cannot test tracker ${tracker}: ${e.message}`, 'error');
          }
        });
      }, 2000);
    });
  </script>
</body>
</html>

